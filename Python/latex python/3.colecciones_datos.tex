\section{Colecciones de datos}


\subsection{Listas}

Las \textbf{listas} son los \textbf{vectores}, \textbf{matrices} o \textbf{arreglos} de otros lenguajes de programación, son tipos que almacenan una cantidad finita de elementos de un mismo tipo, pero, la peculiaridad en este lenguaje, es que en una lista puedes almacenar elementos de distintos tipos de datos. Estructura y ejemplos:
\begin{lstlisting}
    <nombre lista> = [<elemento 1>, <elemento 2>, ..., <elemento n> ] # Estructura de declaración de una lista.

    nombres = ["mario", 'kevin', "jose", 'enrique] # Ejemplo de declaración de una lista string.
    nums = [0, 9, 1, 8, 7, 6] # Ejemplo de declaración de una lista int.
    variado = [99, "cien", 9, "kkk"] # Ejemplo de declaración de una lista con varios tipos de datos.
\end{lstlisting}

Como podemos ver, los ejemplos son declarados de un tipo e inicializados con n cantidad de elementos, para acceder a ellos, trabajarlos o desplegarlos, utilizamos el \textbf{operador[]}, cada elemento posee un \textbf{índice}, que va de 0 a n, entonces, desplegaremos como ejemplo un elemento de una de las listas anteriores en el siguiente ejemplo:
\begin{lstlisting}
    print(nombres[1]) # Despliega "kevin".
    print(numbs[0]) # Despliega 0.
    print(variado[3]) # Despliega "kkk".
\end{lstlisting}

Podemos hacer que los elementos de una lista sean listas también, agregando una dimensión adicional a la lista (como los arreglos multidimensionales), como se ve a continuación:
\begin{lstlisting}
    nums = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    n = [0, [1, 2, 3], 9, [2, 2, 2], 1, 3, 5, [6, 7, 8]] # Ejemplo de declaración de una lista int.
	
    print(nums[1][1]) # Imprime 5.
    print(n[0]) # Imprime 0.
    print(n[1][0]) # Imprime 1.
\end{lstlisting}

Apreciamos que, para acceder a un elemento multidimensional de una lista, existen n pares de llaves cuadradas ([]), donde van ingresados los índices del elemento al que queremos acceder. Cuando son multidimensional las listas, podemos ver las listas de dos dimensiones como tablas, con filas y columnas, donde Python primero recorre las filas y luego las columnas para posicionarse en el elemento con índice solicitado; cuando la lista tiene elementos listas y elementos que no son listas, podemos ver que al elemento que no es lista solo se le aplica el uso de un par de llaves cuadradas, mientras a los elementos lista si se les aplica el uso de varios pares de llaves cuadradas.

Podemos aplicar el uso del \textit{operador[]} a las cadenas. Si tenemos una variable cadena y utilizamos el par de llaves cuadradas con un número entero como índice, accedemos al carácter en dicho índice de la cadena, como vemos en el siguiente ejemplo:
\begin{lstlisting}
    nombre = 'Luis' # Declara e inicializa cadena con nombre.
    print(nombre[1]) # Despliega "u".
\end{lstlisting}

También podemos acceder a ciertos elementos de la lista, utilizando los \textbf{dos puntos (:)} dentro de los paréntesis cuadrados del nombre de la lista:
\begin{lstlisting}
	nums = [1, 3, 5, 7, 9, 11]
	
	print(nums[0:1]) # Imprime 1.
	print(n[1:4]) # Imprime 3, 5, 7.
	print(n[4:5]) # Imprime 11.
\end{lstlisting}

Puede pasar que olvidemos escribir un número en alguno de los dos lados de los dos puntos, sin embargo, esto no es un error, podemos obtener los elementos partiendo de uno de los dos números escritos del lado izquierdo o derecho de los dos puntos, además, podemos obtenerlos de uno en uno, dos en dos, tres en tres, etc:
\begin{lstlisting}
	nums = [1, 3, 5, 7, 9, 11]
	
	print(n[:3]) # Imprime 1, 3, 5.
	print(n[1:]) # Imprime 3, 5, 7, 9, 11.
	print(n[1:5:2]) # Imprime 3, 7.
	print(n[1::2]) # Igual que la instrucción anterior.
\end{lstlisting}

A su vez, podemos obtener los elementos de una lista de manera negativa, es decir, de n elemento hacía atrás:
\begin{lstlisting}
	nums = [1, 3, 5, 7, 9, 11]
	
	print(n[:4:-1]) # Imprime 7, 5, 3, 1.
	print(n[::-1]) # Imprime 11, 9, 7, 5, 3, 1.
\end{lstlisting}


\subsubsection{Operaciones con listas}

Puedes realizar distintas operaciones similares a las que se pueden hacer con cadenas y con otras expresiones, como vemos en la \textit{Tabla \ref{tab: 7}}:
\begin{table}[H]
    \begin{center}
        \caption{Operaciones con listas}
        \label{tab: 7}
        \begin{tabular}{m{4cm} m{5cm} m{4cm}}
            \hline
            \textbf{Operación} & \textbf{Significado} & \textbf{Ejemplo} \\
            \hline
            Asignación de valor a un elemento en concreto		& Puedes acceder a un elemento de la lista y cambiar su valor		& n = [1, 3, 5] n[0] = 33 print(n) \\
            Sumas una lista a otra								& Puedes agregarle una lista a otra con el operador +				& n = [1, 3, 5] n += [7, 9, 11] print(n) \\
            \parbox{4cm}{\raggedright Operaciones aritméticas entre elementos}			& Puedes sumar, multiplicar, restar, dividir u obtener el residuo de una división entre elementos de una misma lista o distintas							& n = [1, 3, 5] m = [7, 9, 11] print(n[1] // m[1]) \\
            Multiplicación de listas							& Repite todos los elementos de una lista n cantidad de veces		& n = [1, 3, 5] print(n * 4) \\
            \parbox{4cm}{\raggedright Búsqueda de un elemento}								& \parbox{5cm}{\raggedright Se busca un elemento en una lista utilizando la palabra reservada \textbf{in}, regresa True si lo halló, en caso contrario, regresa False}						& \parbox{4cm}{\raggedright n = [1, 3, 5] if (7 in n): print("Encontrado") else: print("No encontrado") print(1 in n)} \\
            \parbox{4cm}{\raggedright Comprobar si un elemento no está en la lista}			& \parbox{5cm}{\raggedright Se comprueba si un elemento no existe en una lista con la palabra reservada \textbf{not}, regresa True si no existe, en caso contrario, regresa False}	& \parbox{4cm}{\raggedright n = [1, 3, 5] if (7 not n): print("No existe") else: print("Existe") print(1 not n)} \\
            \hline
        \end{tabular}
    \end{center}    
\end{table}


\subsubsection{Funciones de listas}

La \textit{Tabla \ref{tab: 8}} contiene algunas de las funciones más útiles de las listas son:
\begin{table}[H]
    \begin{center}
        \caption{Funciones especiales para listas}
        \label{tab: 8}
        \begin{tabular}{m{4cm} m{5cm} m{4cm}}
            \hline
            \textbf{Función}&\textbf{Significado}&\textbf{Ejemplo} \\
            \hline
            \textbf{len(lista)}					& Regresa la cantidad de elementos										& len(lista) \\
            \textbf{append(elemento)}			& Agrega un elemento al final de la lista								& lista.append(4) \\
            \parbox{4cm}{\textbf{insert(índice,\\elemento)}}	& Agrega un elemento en el índice deseado 								& lista.insert(0, 10) \\
            \textbf{index(elemento)}			& \parbox{5cm}{\raggedright Regresa el índice de la primer aparición de un elemento en la lista}	& letras.index("r") \\
            \textbf{max(lista)}					& Regresa el valor más alto de la lista									& max(numeros) \\
            \textbf{min(lista)}					& \parbox{5cm}{\raggedright Regresa el valor más pequeño de la lista}								& min(numeros) \\
            \textbf{count(elemento)}			& Regresa la cantidad de veces que se repite un elemento en la lista	& letras.count("r") \\
            \textbf{remove(elemento)}			& Remueve un elemento existente de la lista								& letras.remove("r") \\
            \textbf{reverse()}					& Invierte los elementos de la lista										& numeros.reverse() \\
            \hline
        \end{tabular}
    \end{center}    
\end{table}


\subsubsection{Listas con reglas}

Podemos declarar elementos de una lista siguiendo una condicional o un ciclo, por ejemplo, declarar los elementos de una lista que estén elevados a la tercera potencia, o que sean números pares, etc. Esto se consigue metiendo ciclos for o condicionales dentro de los paréntesis cuadrados [], como vemos ahora:
\begin{lstlisting}
    # Declara lista con cinco elementos a la tercera potencia.
    cubos = [i ++ 3 for i in range(5)]

    print(cubos) # Imprime [0, 1, 8, 27, 64].

    # Declara lista con números al cuadrado y que sean pares.
    pares = [i ** 2 for i in range(10) if i ** 2 % 2 == 0]

    print(pares) # Imprime [0, 4, 16, 36, 64]
\end{lstlisting}


\subsubsection{Ordenamiento de listas}

La forma nativa para ordenar una lista en Python es por medio de la función de listas \textbf{sort()}:
\begin{lstlisting}
    # Declara lista con números.
    numeros = [16, 4, 9, 1, 3, 20, 8]
    # Llamada a la función que ordena ascendentemente una lista.
    numeros.sort()
    # Imprime la lista.
    print(numeros)
	
    # Imprime: [1, 3, 4, 8, 9, 16, 20]
\end{lstlisting}

Esta función cambia a la lista propiamente, si queremos crear una lista ordenada a partir de una desordenada, podemos utilizar la función \textbf{sorted()}:
\begin{lstlisting}
    # Declara lista con números.
    numeros = [16, 4, 9, 1, 3, 20, 8]
    # Asigna a una nueva lista la llamada a la función que ordena ascendentemente una lista.
    nums = numeros.sorted()
    # Imprime las lista.
    print(numeros)
    print(nums)
	
    # Imprime:
    # [16, 4, 9, 1, 3, 20, 8]
    # [1, 3, 4, 8, 9, 16, 20]
\end{lstlisting}

Por defecto en ambas funciones, las listas son ordenadas de manera ascendente, sin embargo, los dos métodos poseen un parámetro llamado \textbf{reverse}, el cual está inicializado en \textit{false}, si cambiamos su valor a \textit{true}, la lista será ordenada descendentemente:
\begin{lstlisting}
    # Declara lista con números.
    numeros = [16, 4, 9, 1, 3, 20, 8]
    # Llamada a la función que ordena descendentemente una lista.
    numeros.sort(reverse=true)
    # Imprime la lista.
    print(numeros)
	
    # Imprime: [20, 16, 9, 8, 4, 3, 1]
\end{lstlisting}

Si se quiere ordenar una lista irregular (que contenta cadenas, caracteres, números o decimales), las función sort y sorted lanzarán un error.


\subsection{Pilas}

Las \textbf{pilas} son una estructura de datos que sigue la filosofía de Último en llegar, Primer en irse (LIFO, Last In, First Out), estas pueden ser estáticas (no cambia tope de elementos) o dinámicas (cambia su tope de elementos durante ejecución).

Python no suele ser estático, por lo cual, las pilas tampoco, se les puede establecer un número tope de elementos a almacenar, pero se mantiene su esencia dinámica; en otros lenguajes, existen librerías o clases que deben ser importadas o adjuntadas a nuestro proyecto para trabajar con métodos especializados para pilas, sin embargo, este lenguaje no posee algo similar, las \textbf{listas} son pilas en sí, así que nos limitaremos simplemente a crear una clase con las funciones básicas de una pila:
\begin{lstlisting}
    class Pila:
	def __init__(self):
		self.pila = []

	def agregar_elemento(self, elemento):
		self.pila.append(elemento)

	def eliminar_elemento(self. elemento):
		self.pila.pop()

	def verificar_vacia(self):
		return self.pila == []

	def buscar_elemento(self, elemento):
		if elemento in self.pila:
			return true
		else
			return false

	def desplegar_elementos(self):
		print(self.pila)

	def vaciar_pila(self):
		self.pila.clear()
\end{lstlisting}

La clase posee un método para agregar, eliminar, recorrer, buscar y vaciar la pila, además de verificar si está vacía o no, esto gracias a las funciones de las listas. La lista actúa como una pila debido a que la función \textbf{append()} agrega los elementos al final de la lista (se agrega el primero, se agrega el segundo después y el primero se recorre, entonces el segundo ahora es el primero y así sucesivamente), y la función \textbf{pop()} elimina el último elemento de la lista, respetando así que el último elemento entrar es el primero en salir o ser eliminado.


\subsection{Colas}

Las \textbf{pilas} son una estructura de datos que sigue la filosofía de Primero en llegar, Primer en irse (FIFO, First In, First Out), estas pueden ser estáticas (no cambia tope de elementos) o dinámicas (cambia su tope de elementos durante ejecución).

A diferencia de las pilas, esta estructura si cuenta con un módulo que podemos importar a Python, la cual es llamada \textbf{deque}:
\begin{lstlisting}
    from collections import deque
\end{lstlisting}

Dejaremos las operaciones básicas que se pueden realizar con las colas y su módulo importado en una clase:
\begin{lstlisting}
    from collections import deque

    class Cola:
	def __init__(self, cola):
		self.cola = []

	def agregar_elemento(self, elemento):
		self.cola.append(elemento)

	def eliminar_elemento(self. elemento):
		self.cola.popleft()

	def verificar_vacia(self):
		return self.cola == []

	def buscar_elemento(self, elemento):
		return elemento in self.cola

	def desplegar_elementos(self):
		print(self.cola)

	def vaciar_cola(self):
		self.cola.clear()
\end{lstlisting}

\textit{Nota}: fíjese que el método para eliminar un elemento de la cola es llamado \textbf{popleft()}, esto es así debido a que el módulo \textbf{deque} tiene dos métodos para eliminar elementos: el anterior mencionado y \textbf{popright()}.

Para poder trabajar con esta clase y el módulo \textit{deque}, primero debemos crear un objeto del módulo anterior y, posterior a ello, crear un objeto de la clase que nosotros creamos, y pasarle como parámetro el objeto \textit{deque}; podríamos trabajar tranquilamente solamente con el objeto deque y sus métodos mostrados en el ejemplo anterior, pero para mayor comodidad de lectura, decidimos implementarlo dentro de una clase:
\begin{lstlisting}
    # Si se imprime la siguiente línea, resulta en una lista vacía.
    nueva_cola = deque()

    clase_cola = Cola(nueva_cola)
\end{lstlisting}


\subsection{Rangos}

Los \textbf{rangos} son una lista con una secuencia de números dada, si requerimos una lista con los números del 1 al 100, podemos utilizar esta herramienta, \textbf{no regresa el último número} (si queremos un rango de 1 al 100, obtenemos el rango del 0 al 99, ya sabemos que muchos lenguajes de programación utilizan el 0 como primer valor de iteración). Un ejemplo de los rangos con tres tipos de casos.
\begin{lstlisting}
    numeros = range(100) # Genera un rango de 100 numeros (0 - 99).
    x = range(1, 20) # Genera un rango de uno a 19 (1 - 19).
    y = range(1, 30, 3) # Genera un rango de uno a 30 de tres en tres (1, 4, 7, 10, ..., 28).
    z = range(100, 1, -5) # Genera un rango negativo de 100 a uno de menos cinco en menos cinco (100, 95, 90, 85, ..., 5).
	
    for a in range(5):
	print("hola mundo") # Imprime cinco veces el mensaje "hola mundo".
\end{lstlisting}

Como vimos, la función range puede crear rangos negativos, que vaya de n en n números, y pueden ser utilizados para repetir un ciclo for n cantidad de veces.

También podemos convertir los rangos a listas, con la función \textbf{list()}.


\subsection{Diccionarios}

Los \textbf{diccionarios} son un tipo de colección de datos donde cada \textbf{llave} (identificador) tiene un \textbf{valor} (contenido), algo así como una dupla, pero los diccionarios son colecciones de duplas; podemos acceder a los valores de los diccionarios utilizando el nombre del diccionario y su llave.
\begin{lstlisting}
    Nombres = { # Declara diccionario.
        # Inicializa diccionario con tres llaves y valores.
        "David" : 19
        "Maria" : 26
        "Luis" : 21
    }

    print(Nombres["David"]) # Despliega el valor de la llave (19).
\end{lstlisting}

Vemos que se utilizan tipos de datos básicos para las llaves y valores, estos tipos son \textbf{mutables}, quiere decir que puede cambiar de valor o ser modificado, a la par de que puede cambiar de tipo de dato (recordemos que esto no es una buena practica en el diseño de programas, es posible, pero no recomendable); las \textit{listas} también son mutables, por lo que podemos utilizar listas como valores de una llave, no como una llave en sí, si utilizamos una lista como una llave, causaría un error.


\subsubsection{Funciones en diccionarios}

Podemos utilizar las palabras reservadas \textbf{in} o \textbf{not in} para determinar si una llave existe o no en un diccionario; usamos \textbf{get} para desplegar el valor de una llave, algo como el operador [] para acceder al valor, sin embargo, si no se encuentra la llave en el diccionario, despliega otro valor como resultado. Veamos el siguiente ejemplo:
\begin{lstlisting}
    # Declara diccionario.
    Numeros = {
        # Inicializa diccionario con llaves y valores.
        1 : "UNO"
        2 : "DOS"
        3 : "TRES"
        4 : "CUATRO"
        5 : "CINCO"
        6 : "SEIS"
        7 : "SIETE"
    }

    # Si no existe la llave en numeros, despliega mensaje.
    if (8 not in Numeros):
        print("No existe esa llave.")
        # Si 1 existe en mensaje, despliega su valor.
    elif (1 in Numeros):
        print(Numeros[1])
        # Busca la llave 2 y despliega su valor, sino, despliega "Ese es un dos".
        print(Numeros.get(2, "Ese es un dos"))
\end{lstlisting}


\subsection{Tuplas}

Las \textbf{tuplas} son como las listas, pero \textbf{inmutables} (no puedes cambiar el valor de uno de sus elementos, si lo intentas, ocurrirá un error), se inicializa con paréntesis (o sin los paréntesis) y se pueden acceder a sus elementos por medio del operador [], como vemos en el siguiente ejemplo:
\begin{lstlisting}
    # Declara diccionario.
    Nombres = {
        "David" : 19
        "Maria" : 26
        "Luis" : 21
    }
   
    # Declara lista.
    Numeros = [1, 2, 3, 4, 5]
   
    # Declara tupla con parentesis.
    Municipios = ("Tijuana", "Mexicali", "Tecate", "Ensenada")
   
    # Declara tupla sin parentesis.
    Estados = "Baja California", "Baja California Sur", "Sonora", "Chihuahua"
   
    print(Municipio[2]) # Despliega Tecate.
   
    Estados[0] = "Quintana Roo" # Error.
\end{lstlisting}

Vemos que las listas son declaradas con paréntesis cuadrados [], los diccionarios con llaves \{\}, y las tuplas con paréntesis ().

Pueden ser utilizadas las tuplas en las listas, si recordamos, mencionamos previamente que los diccionarios pueden contener tipos de datos mutables, no inmutables para las llaves, sin embargo, podemos crear un diccionario y que sus elementos sean tuplas, esto da como resultado un diccionario con valores que no pueden ser modificados, logrando así mantener la integridad de los datos.


\subsubsection{Desempacando tuplas}

Si tenemos un conjunto de variables y una tupla con la misma cantidad de elementos dentro de ella, podemos asignar cada uno de los elementos a cada una de las variables, a esta acción se le llama \textbf{desempacar tuplas}, además, podemos asignar todos los elementos a la derecha de una tupla a una sola variable, con el operador *, como vemos a continuación:
\begin{lstlisting}
    # Declara tupla.
    Municipios = ("Tijuana", "Mexicali", "Tecate", "Ensenada")

    # Declara tupla.
    Estados = "Baja California", "Baja California Sur", "Sonora", "Chihuahua"

    # A a se le asigna Tijuana, a b se le asigna Mexicali,
    # a c se le asigna Tecate, y a d se le asigna Ensenada.
    a, b, c, d = Municipios

    # A e se le asigna Baja California, y a f se le asigna todos los elementos
    # restantes de la tupla.   
    e, *f = Estados   

    # Imprime las variables.
    print(a)
    print(b)
    print(c)
    print(d)
    print(e)
    print(f)
\end{lstlisting}


\subsection{Sets}

Los \textbf{conjuntos} (o \textbf{sets}, como son conocidos), son algo así como una lista o diccionario, pero, a diferencia de las listas, los elementos de un conjunto no deben estar duplicados, a la vez que están desordenados, por lo que no se pueden acceder por medio del operador [], logrando con esto que la búsqueda de los elementos sea más rápida que con las listas.

Si un elemento del conjunto está duplicado, a la hora de imprimirlo, solo se muestra una vez, si se elimina uno de los elementos duplicados, se eliminan el resto de las copias, y si se imprime la cantidad de elementos, se descartan todos los elementos duplicados (si se repite cuatro veces 1, solo se imprime una vez 1).

Se declaran igual que una lista, podemos utilizar los métodos \textbf{add(elemento)},  \textbf{remove(elemento)} y \textbf{len()} para agregar, eliminar un elemento respectivamente y desplegar la cantidad de items del conjunto, como vemos a continuación:
\begin{lstlisting}
    # Declara conjunto con elementos duplicados.
    numeros = {1, 1, 3, 4, 5, 7, 8, 8, 9}

    print(numeros) # Imprime 1, 3, 4, 5, 6, 7, 8, 9.
    print(len(numeros)) # Imprime 7.

    numeros.add(0) # Agrega 0 al conjunto.
    numeros.remove(1) # Elimina todos los 1 del conjunto.

    print(numeros) # Imprime 0, 3, 4, 5, 6, 7, 8, 9.
    print(len(numeros)) # Imprime 7.
\end{lstlisting}


\subsubsection{Operaciones con conjuntos}

Como en las matemáticas, podemos aplicar las operaciones de conjuntos a esta colección de datos (\textit{Tabla \ref{tab: 9}}):
\begin{table}[H]
    \begin{center}
        \caption{Operaciones para conjuntos}
        \label{tab: 9}
        \begin{tabular}{m{4cm} m{5cm} m{4cm}}
            \hline
            \textbf{Operación}&\textbf{Significado}&\textbf{Ejemplo} \\
            \hline
            \textbf{union (|)}					& Regresa la suma de todos los elementos de los conjuntos							& primero | segundo \\
            \textbf{intersection (\&)}			& \parbox{5cm}{\raggedright Regresa solamente los elementos que coinciden en ambos conjuntos}					& primero \& segundo \\
            \textbf{difference (-)}			& Regresa los elementos de un conjunto, pero no del otro, ni los que coinciden	& primero - segundo \\
            \parbox{4cm}{\textbf{symmetric\\difference (\^)}}	& \parbox{5cm}{\raggedright Regresa los elementos que no coinciden en ambos conjuntos}						& primero \^ segundo \\
            \hline
        \end{tabular}
    \end{center}    
\end{table}

El resultado de los ejemplos anteriores se puede ver a continuación:
\begin{lstlisting}
    # Declara dos conjuntos.
    first = {1, 2, 3, 4, 5, 6}
    second = {4, 5, 6, 7, 8, 9}

    print(first | second) # Imprime {1, 2, 3, 4, 5, 6, 7, 8, 9}
    print(first & second) # Imprime {4, 5, 6}
    print(first - second) # Imprime {1, 2, 3}
    print(second - first) # Imprime {8, 9, 7}
    print(first ^ second) # Imprime {1, 2, 3, 7, 8, 9}
\end{lstlisting}


\subsection{Seleccionando una colección de datos}

La siguiente lista da algunos tips sobre como escoger una colección de datos que más se adecue a nuestras necesidades:
\begin{itemize}
	\item Si necesitas dos valores que vayan ligados o tengan una relación directa, velocidad a la hora de buscar valores y, que a su vez, estos valores puedan cambiar, utiliza un \textbf{diccionario}.
	\item Si necesitas un conjunto de datos sin orden y sin relación con otros datos y, que a su vez, sea bastante sencillo e iterable, utiliza una \textbf{lista}.
	\item Si requieres de un conjunto de datos que no estén repetidos, utiliza un \textbf{conjunto}.
	\item Si requieres un conjunto de datos que no puedan ser modificados, utiliza una \textbf{tupla}.
	\item Las \textit{tuplas} pueden ser combinadas con el resto de colecciones de datos.
\end{itemize}
